
# Breeding Programs with Genetic Algorithms


## Bio

Taylor is a hobby-collector and human-guinea-pig. He currently works on video/blockchain software at PopChest. 

If you see Taylor at the conference, say hello! He'd love to hear your insights on software, learning, math, music, hobbies, and self-improvement.


## Abstract

It's a chore to explore search-spaces and tune parameters. Analytic methods produce exact optimizations, but real-world problems rarely have straightforward solutions. And machine-learning is fantastic for most cases, but opaque models can't be easily explained or inspected.

So let's grow solutions with evolutionary computation! In this talk, you'll learn how to tackle messy problems with genetic algorithms. We'll take a practical dive into fitness-functions, populations, and genetic operators. For each concept, we'll discuss tradeoffs, implementation techniques, and common mistakes.

As a bonus, we'll briefly discuss pragmatic metaprogramming. We'll even make a little strange loop: a genetic algorithm that writes genetic algorithms!

You'll love evolutionary computation -- it's in your DNA!


## Keywords

genetic algorithms, evolution, optimization, metaprogramming


## What Will the Attendee Learn?

In this talk, attendees will learn how to tackle messy optimization-problems with genetic algorithms. 

First, we'll look at useful examples of optimization-problems. By the end of this section, the audience will know how to identify places in their own projects where genetic algorithms (and other solvers) might make their jobs easier.

Next, attendees will learn how to define their optimization-problems as fitness-functions. We'll quickly cover common representations for solvers, and how to effectively narrow search-spaces.

Next comes "population" design, which is the starting point for every genetic algorithm. In this section, we'll cover easy methods for generating possible solutions in search-spaces. The audience will also learn how to choose perfect population sizes for their problems and computational limits.

Now that we have populations of programs, the audience will learn to harness the power natural-selection! That is, we'll discuss how to "choose" candidates for breeding in each generation. But maintaining genetic diversity is a difficult balancing-act! By the end of this section, attendees should know how to effectively implement "digital husbandry".

Next, the audience will learn how to combine programs with "genetic operators" like mutation and recombination. We'll look at the tradeoffs of each method, and common implementations. After this section is complete, attendees should have all the basic skills necessary for writing their own genetic algorithms!

Throughout the talk, I'll be using a genetic algorithm to tune parameters of digital creatures, and make them compete against each other. At each step, attendees should see how creatures improve with each modification to the code.
For the finale, we'll make a strange loop! We'll modify our demo into a genetic algorithm that writes genetic algorithms that tunes parameters of creatures! This is surprisingly similar to how DNA effectively bootstrapped itself into existence.

This talk will be a practical guide for the common programmer. But as a bonus, I hope that attendees will leave with a greater appreciation for nature. All life is continually formed by genetic algorithms like the ones in this talk -- it's like a glimpse into nature's source-code!

